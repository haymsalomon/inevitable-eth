<!--
title: commit
description: 
published: true
date: 2022-12-07T17:00:36.946Z
tags: 
editor: ckeditor
dateCreated: 2022-12-07T17:00:25.164Z
-->

<!--
title: KZG Part 1: Commit
description: 
published: true
date: 2022-12-03T05:11:21.184Z
tags: 
editor: undefined
dateCreated: 2022-12-03T03:50:58.623Z
-->

<figure class="image"><img src="/kzg-commit-1.png"></figure>
<p style="text-align:center;"><i>This is part 1 of a 3 part series on KZG Commitments. Here are links to </i><a href="/home/concepts/kzg-commitment/open"><i>part 2</i></a><i>, </i><a href="/home/concepts/kzg-commitment/verify"><i>part 3</i></a><i> and the </i><a href="/home/concepts/kzg-commitment"><i>summary article</i></a><i>.</i></p>
<h1 style="text-align:center;">KZG Commitments Part 1: Commit</h1>
<h2>Prerequisites</h2>
<h3>Elliptic Curve Cryptography</h3>
<p>Elliptic curve cryptography looks unapproachable, but it's totally understandable with a decent amount of high school algebra.&nbsp;</p>
<p>Check out this <a href="/home/concepts/elliptic-curve-cryptography">Into to Elliptic Curve Cryptography</a> and you'll have the math you need to get through this article.</p>
<h2>Pick a Number</h2>
<p>Let's start with an example of a commitment scheme.</p>
<p>Example: Alice bets Bob he can't guess the number she is thinking of.&nbsp;</p>
<p>But Alice can change her number after Bob makes his guess, and so Bob isn't likely to take the bet. Instead, Alice writes down the number, committing to it.&nbsp;</p>
<p>After Bob's guess, she can reveal it.</p>
<h2>A Hash-Based Scheme</h2>
<p>There are many ways to commit to a specific piece of data, the key is to commit in a way that only obscures the data (instead of destroying it).&nbsp;</p>
<p>The most basic example of a commitment scheme is one based on a <a href="/home/concepts/hash">hash function</a>.</p>
<p>Think of a hash function like a black box that takes some input data and irrevocably transforms it into a unique string of nonsense.&nbsp;</p>
<p>Imagine if Alice picks her number, hashes it and provides it to Bob.</p>
<p>By receiving the hash Bob wont have any new info to help him guess.&nbsp;</p>
<p>Once he gets Alice's answer (after guessing) he can hash it and check it against the original hash Alice provided.&nbsp;</p>
<p>The hash commits Alice to the underlying number, but does not leak any information.</p>
<h2>The Problem with Hashing</h2>
<p>The problem with hashing is that it is a very blunt and destructive tool.&nbsp;</p>
<p>Hashing creates a unique, non-reversible fingerprint - the same property that makes it a good commitment candidate also limits how useful it can be.</p>
<p>For example, let's say Carol has a list of 500 numbers and she wants to see if Dennis knows even one of them.&nbsp;</p>
<p>If Carol hashes the whole list, all 500 values get collapsed into a single hash. You can't tell if just one value is in that hash; it's all or nothing.</p>
<p>This is the problem space: how can we commit to a chunk of data in a way that allows us to check specific data points without revealing any extra data?&nbsp;</p>
<p>If I ask "if x = 1, does y = 4?"&nbsp;</p>
<p>We want to answer YES or NO; we do not want to leak any other information.</p>
<h2>Polynomial Commitment Schemes</h2>
<figure class="image"><img src="/polynomial-commitments-1.jpeg"></figure>
<p><a href="/home/concepts/polynomial-commitment">Deep Dive: Polynomial Commitment Schemes</a></p>
<p>Fortunately, we already know our solution: polynomial commitments!&nbsp;</p>
<p>Quick refresher: any data can be represented in polynomial form through a well-understood process called a <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange interpolation</a>.</p>
<p>Data is discrete - it has a finite size with specific values.&nbsp;</p>
<p>To form the polynomial, we break the data into chunks, taking each chunk in order (x) and plotting our data (y).&nbsp;</p>
<p>Polynomial form allows us to derive y-values for ANY x-value, even if it doesn't really exist.</p>
<p>If our data is the word "STUART," we plot the following points:&nbsp;</p>
<ul>
  <li>[1, S]</li>
  <li>[2, T]</li>
  <li>[3, U]</li>
  <li>[4, A]</li>
  <li>[5, R]</li>
  <li>[6, T]</li>
</ul>
<p>Polynomial from allows us to calculate a value for x = 4.5, even though the result is a non-real, nonsense answer.</p>
<p>This is going to form the basis of our commitment scheme. We are going to commit to data by:&nbsp;</p>
<ol>
  <li>converting it to polynomial form</li>
  <li>evaluating the polynomial at some non-sensitive point</li>
  <li>sharing the evaluated value (referred to as the commitment)</li>
</ol>
<h2>Picking a Number</h2>
<p>Here's the important question: which non-sensitive point are we going to use for our commitment?&nbsp;</p>
<p>If the inputs (x) we use to generate our commitment are publicly known, we run into a lot of issues. Most importantly, attackers can easily break and/or overcome the system.</p>
<p>A random number would be perfect; one that neither party knows beforehand (and therefore can't craft attack, producing correct values from the wrong underlying data).&nbsp;</p>
<p>But this is the internet, how are we going to get a random number like that?</p>
<h2>Losing a Number Forever</h2>
<figure class="image"><img src="/pcs-trusted-setup-1.jpeg"></figure>
<p><a href="/home/concepts/pcs-trusted-setup">Deep Dive: PCS Trusted Setup</a></p>
<p>Once again, we've got our solution: an elliptic curve trusted setup! By the end of the setup, we will have irrevocably hidden a secret number (lost forever) in an elliptic curve.&nbsp;</p>
<p>And though the number is forever hidden, it's hidden in a particularly useful way.</p>
<p>Our setup provides us a list of numbers where each number is:&nbsp;</p>
<ul>
  <li>the secret number S</li>
  <li>multiplied by itself i times</li>
  <li>run through our elliptic curve function</li>
</ul>
<p>S<sup>i</sup> is the fundamental building block of the SRS... the exact kind of term we need for our polynomial.</p>
<figure class="image"><img src="/kzg-commit-2.jpeg"></figure>
<p>Notice how the terms created by the trusted setup (specifically the ascending exponent) resemble requirements of the data's polynomial (again, the ascending exponent).</p>
<h2>Committing to an Elliptic Curve</h2>
<figure class="image"><img src="/kzg-commit-3.jpeg"></figure>
<p>Now we are ready, we can commit to our data. We simply check how many terms our polynomial has, grab an equivalent number of points from the SRS and process the polynomial.&nbsp;</p>
<p>The result: you've been able to compute the value of f(S), even though S is permanently a secret!</p>
<p>In fact, our commitment is actually just another point on our elliptic curve! I've written out the (aggressively simplified) math below, but you don't need to worry about it.&nbsp;</p>
<figure class="image"><img src="/kzg-commit-4.jpeg"></figure>
<figure class="image"><img src="/kzg-commit-5.png"></figure>
<p>The important takeaway is simple: a KZG commitment is a point on the underlying elliptic curve.</p>
<h2>Publicly Secure</h2>
<p>Remember, our cryptographic scheme is built around the elliptic curve discrete logarithm problem: in an elliptic curve system, it is EXTRAORDINARY difficult to find X with only X<sup>i</sup>.&nbsp;</p>
<p>And so our commitment can be publicly shared - any information stays secure.</p>
<p>And there we have our KZG commitment! Using the magic of elliptical curve cryptography, we are able to evaluate a function using a secret number.&nbsp;</p>
<p>One that no adversary could know before hand, because NO ONE knows it before hand.&nbsp;</p>
<h2>Resources</h2>
<p>Source Material - <a href="https://twitter.com/SalomonCrypto/status/1583705993300492288">Twitter Link</a></p>
<p>Source Material - <a href="https://inevitableeth.com/twitter-pdf-2022-10-22_kzg_commitment.pdf">PDF</a></p>
