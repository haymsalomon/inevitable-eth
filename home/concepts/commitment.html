<!--
title: Commitment Schemes
description: 
published: true
date: 2022-12-01T23:35:21.910Z
tags: 
editor: undefined
dateCreated: 2022-12-01T23:35:17.826Z
-->

<figure class="image"><img src="/commitment-banner.jpeg"></figure>
<h1 style="text-align:center;">Commitment Schemes</h1>
<h2>Public Assurance</h2>
<p>Let's say you have a large amount of data that, for whatever reason, is private. How can you provide a public audience assurance that you will not alter the data without allowing them to see it?</p>
<p>The naive approach breaks our problem statement's basic privacy assumptions. Revealing the data allows public verification... at the cost of 100% of privacy.&nbsp;</p>
<p>We need to find a way to provide a unique fingerprint of that specific set of data to act as a signature.</p>
<h2>Commitment Schemes</h2>
<figure class="image"><img src="/commitment-1.jpeg"></figure>
<p>Here's the rough schematic of commitment generation:&nbsp;</p>
<ul>
  <li>start with data of arbitrary contents and size&nbsp;</li>
  <li>feed data into a commitment scheme&nbsp;</li>
  <li>commitment scheme generates a commitment, unique to a specific dataset</li>
</ul>
<p>The commitment is some unique piece of data that inseparably bound to the original dataset. Each dataset will generate a different commitment, and each commitment corresponds to a different dataset.&nbsp;</p>
<p>The trick: it is (almost) impossible to go from commitment â†’ dataset.</p>
<p>Because it is INCREDIBLY difficult to go from commitment to dataset, it can be publicly shared without any fear of leaking any of the underlying data.&nbsp;</p>
<p>If we stopped here, we'd still have something useful; digital fingerprints are just as useful as the IRL version.</p>
<p>But we aren't going to stop here, a commitment scheme has a second act: the commitment can be opened!&nbsp;</p>
<p>We still cannot go from commitment to dataset; instead we can combine the commitment with a proof to verify the underlying data.</p>
<figure class="image"><img src="/commitment-2.jpeg"></figure>
<h2>Examples</h2>
<p>Too abstract; let's run through some examples:&nbsp;</p>
<ul>
  <li>Alice is a patron of both BigBank and InsureCo and is processing a transaction that requires both. Instead of communicating it in public, BigBank and InsureCo commit to the same data and share commitments.</li>
  <li>Government worker Bob is distributing [thing] to eligible citizens, but can only identify people through sensitive information (eg a social security/national ID number). Bob shares a commitment to the dataset, which people can use to verify their eligibility.</li>
  <li>Charlie is building blocks for mev-boost. At auction, he cant reveal the block, else someone will just copy it and undercut him. Instead, he submits a commitment, binding him to a block that can be revealed if and only if it is chosen.</li>
</ul>
<p>In summary, the purpose of cryptographic commitment schemes is to publicly bind one party to a specific set of private data in a way that can be revealed later.&nbsp;</p>
<h2>Implementation</h2>
<p>But not all commitment implementations are equal; some are more capable than others. 3 examples...</p>
<h3>Hashing&nbsp;</h3>
<p><a href="/home/concepts/hash">Deep Dive: Hashing</a></p>
<ul>
  <li>Commit: hash your dataset to generate a random-looking string&nbsp;</li>
  <li>Open: reveal the data, making it available for others to hash&nbsp;</li>
  <li>Verify: check the self-computed hash against the commitment</li>
</ul>
<p>While this scheme checks all the boxes of being a commitment scheme, it isn't particularly useful. Opening is an all-or-nothing prospect.&nbsp;</p>
<p>Not only does this have (obvious) implications for privacy, it has pretty aggressive bandwidth assumptions.</p>
<h3>Merkle Trees&nbsp;</h3>
<p><a href="/home/concepts/merkle-tree">Deep Dive: Merkle Trees</a></p>
<ul>
  <li>Commit: generate the tree by applying rounds of hashing between nodes until a single root is remaining&nbsp;</li>
  <li>Open: provide a piece of data and the required inner nodes to self-compute the root&nbsp;</li>
  <li>Verify: compare the self-computed root to the commitment</li>
</ul>
<p>In comparison to a simple hash-based scheme, Merkle trees are an enormous improvement.&nbsp;</p>
<p>First, the commitment can be opened privately at an individual point. The opener will need the inner nodes, but those can be shared without leaking any data in the underlying dataset.</p>
<p>Second, the Merkle trees are MUCH more efficient than a hash-based scheme. Instead of transmitting the entire dataset, Merkle proofs require <a href="https://en.wikipedia.org/wiki/Big_O_notation">O(log n)</a>.&nbsp;</p>
<p>For those of you with a life, O(log n) just means the proof size grows exponentially slower than the dataset size.</p>
<p>Quick aside, while Merkle trees are a huge improvement, they are not perfect. This O(log n) idea is a double-edged sword. Yes, it does grow slower than the dataset, but it will grow, relentless and unceasingly.</p>
<h3>KZG Polynomial Commitments&nbsp;</h3>
<p>Tl;dr KZG commitments allow a party to commit to a dataset in a way that can be opened at any point.&nbsp;</p>
<p>However, unlike Merkle trees, KZG commitments have a constant proof size.&nbsp;</p>
<p>You can prove any amount of evaluations (think millions) with just one 48 byte piece of data!</p>
<h2>Summary</h2>
<p>By now, you've definitely got it. A commitment scheme is about creating commitment that is anchored to a piece of data.&nbsp;</p>
<p>Schemes that can be opened at specific points are particularly useful; the questions are just of commitment calculation efficiency and proof size.</p>
<h2>Resources</h2>
<p>Source Material - <a href="https://twitter.com/SalomonCrypto/status/1586809382813065216">Twitter Link</a></p>
<p>Source Material - <a href="/twitter-pdf-2022-10-30_commitment.pdf">PDF</a></p>
